#include "cgpu/api.h"
#include "utils.h"
#include <filesystem>
#include <fstream>

static const unsigned char raster_cmd_wasm32[] = {
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x29, 0x06, 0x60,
    0x07, 0x7e, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x00, 0x60, 0x05, 0x7e,
    0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x60, 0x02, 0x7e, 0x7e, 0x00, 0x60, 0x03,
    0x7e, 0x7f, 0x7f, 0x00, 0x60, 0x00, 0x00, 0x60, 0x05, 0x7e, 0x7e, 0x7e,
    0x7f, 0x7f, 0x00, 0x02, 0x95, 0x01, 0x04, 0x03, 0x65, 0x6e, 0x76, 0x20,
    0x63, 0x67, 0x70, 0x75, 0x5f, 0x72, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x5f,
    0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x5f, 0x73, 0x65, 0x74, 0x5f,
    0x76, 0x69, 0x65, 0x77, 0x70, 0x6f, 0x72, 0x74, 0x00, 0x00, 0x03, 0x65,
    0x6e, 0x76, 0x1f, 0x63, 0x67, 0x70, 0x75, 0x5f, 0x72, 0x65, 0x6e, 0x64,
    0x65, 0x72, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x72, 0x5f, 0x73,
    0x65, 0x74, 0x5f, 0x73, 0x63, 0x69, 0x73, 0x73, 0x6f, 0x72, 0x00, 0x01,
    0x03, 0x65, 0x6e, 0x76, 0x21, 0x63, 0x67, 0x70, 0x75, 0x5f, 0x72, 0x65,
    0x6e, 0x64, 0x65, 0x72, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x72,
    0x5f, 0x62, 0x69, 0x6e, 0x64, 0x5f, 0x70, 0x69, 0x70, 0x65, 0x6c, 0x69,
    0x6e, 0x65, 0x00, 0x02, 0x03, 0x65, 0x6e, 0x76, 0x18, 0x63, 0x67, 0x70,
    0x75, 0x5f, 0x72, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x5f, 0x65, 0x6e, 0x63,
    0x6f, 0x64, 0x65, 0x72, 0x5f, 0x64, 0x72, 0x61, 0x77, 0x00, 0x03, 0x03,
    0x03, 0x02, 0x04, 0x05, 0x05, 0x03, 0x01, 0x00, 0x02, 0x06, 0x2b, 0x07,
    0x7f, 0x01, 0x41, 0x80, 0x88, 0x04, 0x0b, 0x7f, 0x00, 0x41, 0x80, 0x08,
    0x0b, 0x7f, 0x00, 0x41, 0x80, 0x08, 0x0b, 0x7f, 0x00, 0x41, 0x80, 0x08,
    0x0b, 0x7f, 0x00, 0x41, 0x80, 0x88, 0x04, 0x0b, 0x7f, 0x00, 0x41, 0x00,
    0x0b, 0x7f, 0x00, 0x41, 0x01, 0x0b, 0x07, 0x8b, 0x01, 0x09, 0x06, 0x6d,
    0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x11, 0x5f, 0x5f, 0x77, 0x61,
    0x73, 0x6d, 0x5f, 0x63, 0x61, 0x6c, 0x6c, 0x5f, 0x63, 0x74, 0x6f, 0x72,
    0x73, 0x00, 0x04, 0x11, 0x72, 0x61, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x63,
    0x6d, 0x64, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x00, 0x05, 0x0c,
    0x5f, 0x5f, 0x64, 0x73, 0x6f, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65,
    0x03, 0x01, 0x0a, 0x5f, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x65, 0x6e,
    0x64, 0x03, 0x02, 0x0d, 0x5f, 0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
    0x5f, 0x62, 0x61, 0x73, 0x65, 0x03, 0x03, 0x0b, 0x5f, 0x5f, 0x68, 0x65,
    0x61, 0x70, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x03, 0x04, 0x0d, 0x5f, 0x5f,
    0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x03,
    0x05, 0x0c, 0x5f, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x62, 0x61,
    0x73, 0x65, 0x03, 0x06, 0x0a, 0x4f, 0x02, 0x02, 0x00, 0x0b, 0x4a, 0x00,
    0x20, 0x02, 0x43, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x03, 0xb3, 0x20, 0x04, 0xb3, 0x43, 0x00, 0x00, 0x00, 0x00, 0x43,
    0x00, 0x00, 0x80, 0x3f, 0x10, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x02,
    0x41, 0x00, 0x41, 0x00, 0x20, 0x03, 0x20, 0x04, 0x10, 0x81, 0x80, 0x80,
    0x80, 0x00, 0x20, 0x02, 0x20, 0x01, 0x10, 0x82, 0x80, 0x80, 0x80, 0x00,
    0x20, 0x02, 0x41, 0x03, 0x41, 0x00, 0x10, 0x83, 0x80, 0x80, 0x80, 0x00,
    0x0b
};

#include "filewatch.hpp"

void setup_wasm(SWAInstanceId* wa_instance, SWARuntimeId* wa_runtime, SWAModuleId* wa_module, const uint8_t* bytes, uint32_t bytes_size)
{

    // Only wa_edge support wasm64 now
    SWAInstanceDescriptor inst_desc = { ESWA_BACKEND_WASM3 };
    *wa_instance = swa_create_instance(&inst_desc);
    SWARuntimeDescriptor runtime_desc = { "wa_runtime", 64 * 1024 };
    *wa_runtime = swa_create_runtime(*wa_instance, &runtime_desc);
    SWAModuleDescriptor module_desc;
    module_desc.name = "raster_cmd";
    module_desc.wasm = bytes;
    module_desc.wasm_size = bytes_size;
    module_desc.bytes_pinned_outside = true;
    module_desc.strong_stub = false;
    *wa_module = swa_create_module(*wa_runtime, &module_desc);

    swa::utilx::link(*wa_module, "env", "cgpu_render_encoder_set_viewport", cgpu_render_encoder_set_viewport);
    swa::utilx::link(*wa_module, "env", "cgpu_render_encoder_set_scissor", cgpu_render_encoder_set_scissor);
    swa::utilx::link(*wa_module, "env", "cgpu_render_encoder_bind_pipeline", cgpu_render_encoder_bind_pipeline);
    swa::utilx::link(*wa_module, "env", "cgpu_render_encoder_draw", cgpu_render_encoder_draw);
}

void finalize_wasm(SWAInstanceId wa_instance, SWARuntimeId wa_runtime, SWAModuleId wa_module)
{
    if (wa_module) swa_free_module(wa_module);
    if (wa_runtime) swa_free_runtime(wa_runtime);
    if (wa_instance) swa_free_instance(wa_instance);
}

// Watch triangle_module32.wasm file automatically
struct WasmWatcher {
    WasmWatcher()
    {
        auto cpath = std::filesystem::absolute("triangle_module32.wasm");
        watcher = new filewatch::FileWatch<std::filesystem::path>(cpath,
            [this, cpath](const std::filesystem::path& path, const filewatch::Event change_type) {
                if (change_type == filewatch::Event::renamed_new)
                {
                    std::ifstream ifs(path.c_str());
                    this->content = std::string((std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
                }
            });
        std::ifstream ifs(cpath.c_str());
        content = std::string((std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
    }
    ~WasmWatcher()
    {
        delete watcher;
    }
    std::string content;
    filewatch::FileWatch<std::filesystem::path>* watcher;
};

void* watch_wasm()
{
    return new WasmWatcher();
}

void wasm_glob(void* watcher, const uint8_t** bytes, uint32_t* size)
{
    WasmWatcher* W = (WasmWatcher*)watcher;
    *bytes = (const uint8_t*)W->content.c_str();
    *size = W->content.size();
}

void unwatch_wasm(void* watcher)
{
    delete (WasmWatcher*)watcher;
}

struct SourceWatcher {
    void Compile()
    {
        auto dirstr = watch_path.string().append("compile_32.bat");
        std::string cmdstr;
        {
            std::filesystem::path valid = dirstr;
            cmdstr = cmdstr.append(valid.string());
            system(cmdstr.c_str());
            std::cout << "Recompiled with " << cmdstr << "\n";
        }
    }

    SourceWatcher(std::filesystem::path path)
        : watch_path(path)
    {
        watcher = new filewatch::FileWatch<std::filesystem::path>(path,
            [this](const std::filesystem::path& path, const filewatch::Event change_type) {
                if (change_type == filewatch::Event::modified)
                {
                    auto pathstr = path.string();
                    if (pathstr.find(".wa.") != std::string::npos)
                    {
                        Compile();
                    }
                }
            });
        Compile();
    }
    ~SourceWatcher()
    {
        delete watcher;
    }
    filewatch::FileWatch<std::filesystem::path>* watcher;
    std::filesystem::path watch_path;
};

void* watch_source(const char* dir)
{
    try
    {
        std::filesystem::path watch_path = dir ? std::filesystem::path(dir) : std::filesystem::absolute("");
        return new SourceWatcher(watch_path);
    } //
    catch (std::system_error err)
    {
        std::cout << err.what() << std::endl;
    }
    return nullptr;
}

void unwatch_source(void* watcher)
{
    delete (SourceWatcher*)watcher;
}